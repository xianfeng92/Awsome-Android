

## Android LayoutInflater

LayoutInflater 主要是用于加载布局的。在Activity onCreate中调用的 setContentView() 其实也是用 LayoutInflater 来加载布局的。

先来看一下LayoutInflater的基本用法吧，它的用法非常简单，首先需要获取到LayoutInflater的实例，有两种方法可以获取到，第一种写法如下：

```
LayoutInflater layoutInflater = LayoutInflater.from(context);

```
当然，还有另外一种写法也可以完成同样的效果：

```
LayoutInflater layoutInflater = (LayoutInflater) context
		.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
```

其实第一种就是第二种的简单写法，只是Android给我们做了一下封装而已。得到了LayoutInflater的实例之后就可以调用它的inflate()方法来加载布局了，如下所示：

```
layoutInflater.inflate(resourceId, root);

```

inflate()方法一般接收两个参数，第一个参数就是要加载的布局id，第二个参数是指给该布局的外部再嵌套一层父布局，如果不需要就直接传null。
这样就成功成功创建了一个布局的实例，之后再将它添加到指定的位置就可以显示出来了。

不管使用的哪个inflate()方法的重载，最终都会辗转调用到LayoutInflater的如下代码中：

```
    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
        synchronized (mConstructorArgs) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate");

            final Context inflaterContext = mContext;
            final AttributeSet attrs = Xml.asAttributeSet(parser);
            Context lastContext = (Context) mConstructorArgs[0];
            mConstructorArgs[0] = inflaterContext;
            View result = root;

            try {
                // Look for the root node.
                int type;
                while ((type = parser.next()) != XmlPullParser.START_TAG &&
                        type != XmlPullParser.END_DOCUMENT) {
                    // Empty
                }

                if (type != XmlPullParser.START_TAG) {
                    throw new InflateException(parser.getPositionDescription()
                            + ": No start tag found!");
                }

                final String name = parser.getName();

                if (DEBUG) {
                    System.out.println("**************************");
                    System.out.println("Creating root view: "
                            + name);
                    System.out.println("**************************");
                }

                if (TAG_MERGE.equals(name)) {
                    if (root == null || !attachToRoot) {
                        throw new InflateException("<merge /> can be used only with a valid "
                                + "ViewGroup root and attachToRoot=true");
                    }

                    rInflate(parser, root, inflaterContext, attrs, false);
                } else {
                    // Temp is the root view that was found in the xml 用于根据节点名来创建View对象的
                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                    ViewGroup.LayoutParams params = null;

                    if (root != null) {
                        if (DEBUG) {
                            System.out.println("Creating params from root: " +
                                    root);
                        }
                        // Create layout params that match root, if supplied
                        params = root.generateLayoutParams(attrs);
                        if (!attachToRoot) {
                            // Set the layout params for temp if we are not
                            // attaching. (If we are, we use addView, below)
                            temp.setLayoutParams(params);
                        }
                    }

                    if (DEBUG) {
                        System.out.println("-----> start inflating children");
                    }

                    // Inflate all children under temp against its context. 
                    // rInflate()方法来循环遍历这个根布局下的子元素
                    rInflateChildren(parser, temp, attrs, true);

                    if (DEBUG) {
                        System.out.println("-----> done inflating children");
                    }

                    // We are supposed to attach all the views we found (int temp)
                    // to root. Do that now.
                    if (root != null && attachToRoot) {
                        root.addView(temp, params);
                    }

                    // Decide whether to return the root that was passed in or the
                    // top view found in xml.
                    if (root == null || !attachToRoot) {
                        result = temp;
                    }
                }

            } catch (XmlPullParserException e) {
                final InflateException ie = new InflateException(e.getMessage(), e);
                ie.setStackTrace(EMPTY_STACK_TRACE);
                throw ie;
            } catch (Exception e) {
                final InflateException ie = new InflateException(parser.getPositionDescription()
                        + ": " + e.getMessage(), e);
                ie.setStackTrace(EMPTY_STACK_TRACE);
                throw ie;
            } finally {
                // Don't retain static reference on context.
                mConstructorArgs[0] = lastContext;
                mConstructorArgs[1] = null;

                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }

            return result;
        }
    }

```
上面代码那么多，其实 LayoutInflater 主要就是使用Android提供的pull解析方式来解析布局文件的,最终会把整个布局文件都解析完成后就形成了一个完整的DOM结构，最终会把最顶层的根布局返回。
即上面那一顿操作以后，返回一个根View（DOM树的顶部），__此时我们就可以通过跟View的findViewById从DOM中找到里面的相应子布局(控件)__。

对于每个View的layout_width和layout_height是__设置该控件在View布局中的大小__。也就是说，首先View必须存在于一个布局中，之后如果将layout_width
设置成match_parent表示让View的宽度填充满布局。

而对于平时在Activity中指定布局文件的时候，最外层的那个布局是可以指定大小的呀，layout_width和layout_height都是有作用的。确实，这主要是因为，
在setContentView()方法中，Android会自动在布局文件的最外层再嵌套一个 FrameLayout，所以layout_width和layout_height属性才会有效果。


任何一个Activity中显示的界面其实主要都由两部分组成，标题栏和内容布局。标题栏就是在很多界面顶部显示的那部分内容，比如刚刚我们的那个例子当中就有标题栏，
可以在代码中控制让它是否显示。而内容布局就是一个FrameLayout，这个布局的id叫作content，我们调用setContentView()方法时所传入的布局其实就是放到这个FrameLayout中的，
这也是为什么这个方法名叫作setContentView()，而不是叫setView()。


附上一张Activity窗口的组成图：





所以 LayoutInflater 主要作用是加载和解析我们定义的布局文件，并且能够返回一个DOM树的顶部（最顶层的根View），然后当我们要引用布局文件中的view时，就是通过DOM
树这个结构去查找和获取的。


通过 LayoutInflater 可以获取到布局文件中的View，任何一个View都不可能凭空突然出现在屏幕上，它们都是要经过非常科学的绘制流程后才能显示出来的。
每一个视图的绘制过程都必须经历三个最主要的阶段，即onMeasure()、onLayout()和onDraw()。


## onMeasure()

specMode 一共有三种类型，如下所示：

1. EXACTLY

   表示父视图希望子视图的大小应该是由 specSize 的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。

2. AT_MOST

   表示子视图最多只能是 specSize 中指定的大小，开发人员应该尽可能小得去设置这个视图，并且保证不会超过specSize。
   系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。

3. UNSPECIFIED
   
   表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。



widthMeasureSpec和heightMeasureSpec这两个值又是从哪里得到的呢？通常情况下，这两个值都是由父视图经过计算后传递给子视图的，说明父视图会在一定程度上决定子视图的大小。
但是最外层的根视图，它的widthMeasureSpec和heightMeasureSpec又是从哪里得到的呢？这就需要去分析ViewRoot中的源码了，观察performTraversals()方法可以发现如下代码：

```
childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);

```

可以看到，这里调用了getRootMeasureSpec()方法去获取widthMeasureSpec和heightMeasureSpec的值，注意方法中传入的参数，其中lp.width和lp.height在创建ViewGroup实例的时候就被赋值了，
它们都等于MATCH_PARENT。

```
    private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
    }
```

可以看到，这里使用了MeasureSpec.makeMeasureSpec()方法来组装一个MeasureSpec，当rootDimension参数等于MATCH_PARENT的时候，MeasureSpec的specMode就等于EXACTLY，
当rootDimension等于WRAP_CONTENT的时候，MeasureSpec的specMode就等于AT_MOST。并且MATCH_PARENT和WRAP_CONTENT时的specSize都是等于windowSize的，
也就意味着根视图总是会充满全屏的。


view中的measure方法：

```

    /**
     * <p>
     * This is called to find out how big a view should be. The parent
     * supplies constraint information in the width and height parameters.
     * </p>
     *
     * <p>
     * The actual measurement work of a view is performed in
     * {@link #onMeasure(int, int)}, called by this method. Therefore, only
     * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
     * </p>
     *
     *
     * @param widthMeasureSpec Horizontal space requirements as imposed by the
     *        parent
     * @param heightMeasureSpec Vertical space requirements as imposed by the
     *        parent
     *
     * @see #onMeasure(int, int)
     */
    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
     
                ...

                // measure ourselves, this should set the measured dimension flag back
                onMeasure(widthMeasureSpec, heightMeasureSpec);

               ... 
    }

```
通过注释我们知道，measure()这个方法是final的，因此我们无法在子类中去重写这个方法，说明 Android 是不允许我们改变 View 的 measure 框架的。
只有 onMeasure 可以被子类重写。onMeasure()方法才是真正去测量并设置View大小的地方。

```
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }

```

先看看 getSuggestedMinimumWidth 到底干啥的～

````
    /**
     * Returns the suggested minimum width that the view should use. This
     * returns the maximum of the view's minimum width
     * and the background's minimum width
     *  ({@link android.graphics.drawable.Drawable#getMinimumWidth()}).
     * <p>
     * When being used in {@link #onMeasure(int, int)}, the caller should still
     * ensure the returned width is within the requirements of the parent.
     *
     * @return The suggested minimum width of the view.
     */
    protected int getSuggestedMinimumWidth() {
            //如果没有给View设置背景，那么就返回View本身的最小宽度mMinWidth
           //如果给View设置了背景，那么就取View本身最小宽度mMinWidth和背景的最小宽度的最大值
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }
```

1. 如果没有给View设置背景，那么就返回View本身的最小宽度mMinWidth

2. 如果给View设置了背景，那么就取View本身最小宽度mMinWidth和背景的最小宽度的最大值

有两种办法给View设置最小宽度：

第一种情况是，mMinWidth是在View的构造函数中被赋值的，View通过读取XML中定义的minWidth的值来设置View的最小宽度mMinWidth，
以下代码片段是View构造函数中解析minWidth的部分：

```
//遍历到XML中定义的minWith属性
case R.styleable.View_minWidth:
//读取XML中定义的属性值作为mMinWidth，如果XML中未定义，则设置为0
mMinWidth = a.getDimensionPixelSize(attr, 0);
break;

```

第二种情况是调用View的setMinimumWidth方法给View的最小宽度mMinWidth赋值，setMinimumWidth方法的代码如下所示：

```
public void setMinimumWidth(int minWidth) {
    mMinWidth = minWidth;
    requestLayout();
}
```

Android 会将 View 想要的尺寸以及其父控件对其尺寸限制信息 measureSpec 传递给 getDefaultSize 方法，该方法要根据这些综合信息计算最终的测量的尺寸。

```
    /**
     * Utility to return a default size. Uses the supplied size if the
     * MeasureSpec imposed no constraints. Will get larger if allowed
     * by the MeasureSpec.
     *
     * @param size Default size for this view
     * @param measureSpec Constraints imposed by the parent
     * @return The size this view should be.
     */
    public static int getDefaultSize(int size, int measureSpec) {
        //size表示的是View想要的尺寸信息，比如最小宽度或最小高度
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        //如果mode是UNSPECIFIED，表示View的父ViewGroup没有给View在尺寸上设置限制条件
        case MeasureSpec.UNSPECIFIED:
        //此处当mode是UNSPECIFIED时，View就直接用自己想要的尺寸size作为测量的结果
            result = size;
            break;
        //如果mode是 AT_MOST，那么表示View最大可以取其父ViewGroup给其指定的尺寸
        //如果mode是 EXACTLY，那么表示View必须使用其父ViewGroup指定的尺寸
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
        //此处mode是 AT_MOST 或 EXACTLY 时，View就用其父ViewGroup指定的尺寸作为测量的结果
            break;
        }
        return result;
    }

```

* 首先根据 measuredSpec 解析出对应的 specMode 和 specSize

* 当mode是 UNSPECIFIED 时，View就直接用自己想要的尺寸size作为测量的结果

* 当mode是 AT_MOST 或 EXACTLY时，View就用其父ViewGroup指定的尺寸作为测量的结果

最终，View会根据measuredSpec限制条件，得到最终的测量的尺寸。

这样在onMeasure方法中， 当执行getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec)时，我们就得到了最终测量到的宽度值； 
当执行getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)时，我们就得到了最终测量到的高度值。






























