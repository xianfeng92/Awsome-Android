# @Component

Component 管理着依赖实例，根据依赖实例之间的关系就能确定 Component 的关系。这些关系可以用 object graph描述，我称之为依赖关系图。在 Dagger 2 中 Component 
的组织关系分为两种:依赖关系和继承关系。

依赖关系，一个 Component 依赖__其他 Compoent 公开的依赖实例__，用 Component 中的 dependencies 声明。__被依赖的 Component 需要把暴露的依赖实例用显式的接口声明__。


```
public class Son {
    @Inject
    Car car;
    @Inject
    Airplane airplane;

    public void goDongBei(){
        car.run();
        airplane.fly();
    }
}
```

用 dependencies 声明 SonComponent 依赖于 FatherComponent：

```
@Component(modules = SonModule.class,dependencies = FatherComponent.class)
public interface SonComponent {
    void inject(Son son);
}
```

在 FatherComponent 中定义其可以暴露给 SonComponent 所依赖的对象：

```
@Component(modules = FatherModule.class)
public interface FatherComponent {
    void inject(Person person);
    Car car();
}
```

SonModule 中提供了 Son 所需的 Airplane 依赖：
```
@Module
public class SonModule {
    @Provides
    Airplane provideAirplane(){
        return new Airplane();
    }
}
```


```
Son son = new Son();
FatherComponent fatherComponent = DaggerFatherComponent.builder().build();
DaggerSonComponent.builder().fatherComponent(fatherComponent).build().inject(son);
son.goDongBei();
```

## 源码分析

```
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.example.di.component;

public final class DaggerSonComponent implements SonComponent {
  private Provider<Car> carProvider;

  private Provider<Airplane> provideAirplaneProvider;

  private MembersInjector<Son> sonMembersInjector;

  private DaggerSonComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {

    this.carProvider =
        new Factory<Car>() {
          private final FatherComponent fatherComponent = builder.fatherComponent;

          @Override
          public Car get() {
            return Preconditions.checkNotNull(
                fatherComponent.car(), "Cannot return null from a non-@Nullable component method");
          }
        };

    this.provideAirplaneProvider = SonModule_ProvideAirplaneFactory.create(builder.sonModule);

    this.sonMembersInjector = Son_MembersInjector.create(carProvider, provideAirplaneProvider);
  }

  @Override
  public void inject(Son son) {
    sonMembersInjector.injectMembers(son);
  }

  public static final class Builder {
    private SonModule sonModule;

    private FatherComponent fatherComponent;

    private Builder() {}

    public SonComponent build() {
      if (sonModule == null) {
        this.sonModule = new SonModule();
      }
      if (fatherComponent == null) {
        throw new IllegalStateException(FatherComponent.class.getCanonicalName() + " must be set");
      }
      return new DaggerSonComponent(this);
    }

    public Builder sonModule(SonModule sonModule) {
      this.sonModule = Preconditions.checkNotNull(sonModule);
      return this;
    }

    public Builder fatherComponent(FatherComponent fatherComponent) {
      this.fatherComponent = Preconditions.checkNotNull(fatherComponent);
      return this;
    }
  }
}

```


















