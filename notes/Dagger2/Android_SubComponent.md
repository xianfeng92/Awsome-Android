
# SubComponent

一个 Component 继承（也可以叫扩展）某 Component 提供更多的依赖，SubComponent 就是继承关系的体现。 __继承关系中不用显式地提供暴露依赖实例的接口__


```
/**
 * Created By zhongxianfeng on 19-4-17
 * github: https://github.com/xianfeng92
 */
@Subcomponent(modules = SonModule.class)
public interface SonComponent {

    void inject(Son son);

    @Subcomponent.Builder
    interface Builder{
        SonComponent build();
    }
}
```


```
@Component(modules = FatherModule.class)
public interface FatherComponent {
    void inject(Person person);

    SonComponent.Builder sonComponent();
}
```

```

/**
 * Created By zhongxianfeng on 19-4-17
 * github: https://github.com/xianfeng92
 */
@Module(subcomponents = SonComponent.class)
public class FatherModule {

    @Provides
    public Car provideCar(){
        return new Car();
    }

}
```


```
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).
package com.example.di.component;

public final class DaggerFatherComponent implements FatherComponent {
  private Provider<Car> provideCarProvider;

  private MembersInjector<Person> personMembersInjector;

  private Provider<SonComponent.Builder> sonComponentBuilderProvider;

  private DaggerFatherComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static FatherComponent create() {
    return builder().build();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {

    this.provideCarProvider = FatherModule_ProvideCarFactory.create(builder.fatherModule);

    this.personMembersInjector = Person_MembersInjector.create(provideCarProvider);

    this.sonComponentBuilderProvider =
        new Factory<SonComponent.Builder>() {
          @Override
          public SonComponent.Builder get() {
            return new SonComponentBuilder();
          }
        };
  }

  @Override
  public void inject(Person person) {
    personMembersInjector.injectMembers(person);
  }

  @Override
  public SonComponent.Builder sonComponent() {
    return sonComponentBuilderProvider.get();
  }

  public static final class Builder {
    private FatherModule fatherModule;

    private Builder() {}

    public FatherComponent build() {
      if (fatherModule == null) {
        this.fatherModule = new FatherModule();
      }
      return new DaggerFatherComponent(this);
    }

    public Builder fatherModule(FatherModule fatherModule) {
      this.fatherModule = Preconditions.checkNotNull(fatherModule);
      return this;
    }
  }

  private final class SonComponentBuilder implements SonComponent.Builder {
    private SonModule sonModule;

    @Override
    public SonComponent build() {
      if (sonModule == null) {
        this.sonModule = new SonModule();
      }
      return new SonComponentImpl(this);
    }
  }

  private final class SonComponentImpl implements SonComponent {
    private Provider<Airplane> provideAirplaneProvider;

    private MembersInjector<Son> sonMembersInjector;

    private SonComponentImpl(SonComponentBuilder builder) {
      assert builder != null;
      initialize(builder);
    }

    @SuppressWarnings("unchecked")
    private void initialize(final SonComponentBuilder builder) {

      this.provideAirplaneProvider = SonModule_ProvideAirplaneFactory.create(builder.sonModule);

      this.sonMembersInjector =
          Son_MembersInjector.create(
              DaggerFatherComponent.this.provideCarProvider, provideAirplaneProvider);
    }

    @Override
    public void inject(Son son) {
      sonMembersInjector.injectMembers(son);
    }
  }
}

```



```
public final class FatherModule_ProvideCarFactory implements Factory<Car> {
  private final FatherModule module;

  public FatherModule_ProvideCarFactory(FatherModule module) {
    assert module != null;
    this.module = module;
  }

  @Override
  public Car get() {
    return Preconditions.checkNotNull(
        module.provideCar(), "Cannot return null from a non-@Nullable @Provides method");
  }

  public static Factory<Car> create(FatherModule module) {
    return new FatherModule_ProvideCarFactory(module);
  }
}
```


```
public final class Son_MembersInjector implements MembersInjector<Son> {
  private final Provider<Car> carProvider;

  private final Provider<Airplane> airplaneProvider;

  public Son_MembersInjector(Provider<Car> carProvider, Provider<Airplane> airplaneProvider) {
    assert carProvider != null;
    this.carProvider = carProvider;
    assert airplaneProvider != null;
    this.airplaneProvider = airplaneProvider;
  }

  public static MembersInjector<Son> create(
      Provider<Car> carProvider, Provider<Airplane> airplaneProvider) {
    return new Son_MembersInjector(carProvider, airplaneProvider);
  }

  @Override
  public void injectMembers(Son instance) {
    if (instance == null) {
      throw new NullPointerException("Cannot inject members into a null reference");
    }
    instance.car = carProvider.get();
    instance.airplane = airplaneProvider.get();
  }

  public static void injectCar(Son instance, Provider<Car> carProvider) {
    instance.car = carProvider.get();
  }

  public static void injectAirplane(Son instance, Provider<Airplane> airplaneProvider) {
    instance.airplane = airplaneProvider.get();
  }
}
```




```
public final class SonModule_ProvideAirplaneFactory implements Factory<Airplane> {
  private final SonModule module;

  public SonModule_ProvideAirplaneFactory(SonModule module) {
    assert module != null;
    this.module = module;
  }

  @Override
  public Airplane get() {
    return Preconditions.checkNotNull(
        module.provideAirplane(), "Cannot return null from a non-@Nullable @Provides method");
  }

  public static Factory<Airplane> create(SonModule module) {
    return new SonModule_ProvideAirplaneFactory(module);
  }

  /** Proxies {@link SonModule#provideAirplane()}. */
  public static Airplane proxyProvideAirplane(SonModule instance) {
    return instance.provideAirplane();
  }
}
```











































