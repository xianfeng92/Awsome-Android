
# SubComponent

一个 Component 继承某 Component 提供更多的依赖，SubComponent 就是继承关系的体现。

Subcomponent 表明 SonComponent 是一个子 Component，在 SonComponent 中还提供了一个可以构建 SonComponent 的 Builder。

```
@Subcomponent(modules = SonModule.class)
public interface SonComponent {

    void inject(Son son);

    @Subcomponent.Builder
    interface Builder{
        SonComponent build();
    }
}
```

FatherComponent 中声明了一个 sonComponent()

```
@Component(modules = FatherModule.class)
public interface FatherComponent {
    void inject(Person person);

    SonComponent.Builder sonComponent();
}
```


```
@Module(subcomponents = SonComponent.class)
public class FatherModule {

    @Provides
    public Car provideCar(){
        return new Car();
    }

}
```


```
FatherComponent fatherComponent;
Son son = new Son();
fatherComponent = DaggerFatherComponent.builder().build();
fatherComponent.sonComponent().build().inject(son);
```

1. SonComponent 继承 FatherComponent，继承的是依赖，是 FatherComponent 对应的 module 中所提供的依赖。

2. 类比于Java继承中对象的构建，Dagger 中也是要先构建 FatherComponent 对象，然后再去构建 SonComponent 对象
   即，先 DaggerFatherComponent.builder().build() 构建一个 fatherComponent，然后再去 fatherComponent.sonComponent().build() 
   构建 SonComponent 对象。

3. FatherComponent 对象构建好了意味着什么呢？意味着 FatherComponent 所连接的依赖已经就绪，只待注入。

4. 为什么利用 FatherComponent 对象去构建 SonComponent 对象呢？ 
   因为 sonComponent 中需要 fatherComponent 中的依赖。在 fatherComponent.sonComponent().build() 过程中，fatherComponent 会将其连接的所有依赖的引用
   传递给 sonComponent。


## 源码分析

### DaggerFatherComponent 对象的构建

#### 调用 DaggerFatherComponent.builder().build() 构建 DaggerFatherComponent 对象。

```
  DaggerFatherComponent#initialize()
  private void initialize(final Builder builder) {

    this.provideCarProvider = FatherModule_ProvideCarFactory.create(builder.fatherModule);

    this.personMembersInjector = Person_MembersInjector.create(provideCarProvider);

    this.sonComponentBuilderProvider =
        new Factory<SonComponent.Builder>() {
          @Override
          public SonComponent.Builder get() {
            return new SonComponentBuilder();
          }
        };
  }
```

1. 在构建 DaggerFatherComponent 对象中，使用简单工厂模式生成一个 sonComponentBuilderProvider 对象，该对象主要
   用来提供 sonComponentBuilder 对象，sonComponentBuilder 就是用来构建 sonComponent。
   
2. DaggerFatherComponent 对象中有一个 sonComponentBuilderProvider 对象


#### 调用 fatherComponent.sonComponent().build() 构建 FatherComponent 对象

先看看 fatherComponent#sonComponent()，

```
  @Override
  public SonComponent.Builder sonComponent() {
    return sonComponentBuilderProvider.get();
  }
```
sonComponent() 方法返回就是一个 SonComponentBuilder 对象。

```
  private final class SonComponentBuilder implements SonComponent.Builder {
    private SonModule sonModule;

    @Override
    public SonComponent build() {
      if (sonModule == null) {
        this.sonModule = new SonModule();
      }
      return new SonComponentImpl(this);
    }
  }
```

```
  private final class SonComponentImpl implements SonComponent {
    private Provider<Airplane> provideAirplaneProvider;

    private MembersInjector<Son> sonMembersInjector;

    private SonComponentImpl(SonComponentBuilder builder) {
      assert builder != null;
      initialize(builder);
    }

    @SuppressWarnings("unchecked")
    private void initialize(final SonComponentBuilder builder) {

      this.provideAirplaneProvider = SonModule_ProvideAirplaneFactory.create(builder.sonModule);

      this.sonMembersInjector =
          Son_MembersInjector.create(
              DaggerFatherComponent.this.provideCarProvider, provideAirplaneProvider);
    }

    @Override
    public void inject(Son son) {
      sonMembersInjector.injectMembers(son);
    }
  }
```
DaggerFatherComponent.this.provideCarProvider 引用传给 sonMembersInjector，这样 SonComponent 就可以利用 sonMembersInjector
将 Car 依赖注入到所需的地方。


## 源码如下

#### DaggerFatherComponent

```
// Generated by dagger.internal.codegen.ComponentProcessor (https://google.github.io/dagger).

public final class DaggerFatherComponent implements FatherComponent {
  private Provider<Car> provideCarProvider;

  private MembersInjector<Person> personMembersInjector;

  private Provider<SonComponent.Builder> sonComponentBuilderProvider;

  private DaggerFatherComponent(Builder builder) {
    assert builder != null;
    initialize(builder);
  }

  public static Builder builder() {
    return new Builder();
  }

  public static FatherComponent create() {
    return builder().build();
  }

  @SuppressWarnings("unchecked")
  private void initialize(final Builder builder) {

    this.provideCarProvider = FatherModule_ProvideCarFactory.create(builder.fatherModule);

    this.personMembersInjector = Person_MembersInjector.create(provideCarProvider);

    this.sonComponentBuilderProvider =
        new Factory<SonComponent.Builder>() {
          @Override
          public SonComponent.Builder get() {
            return new SonComponentBuilder();
          }
        };
  }

  @Override
  public void inject(Person person) {
    personMembersInjector.injectMembers(person);
  }

  @Override
  public SonComponent.Builder sonComponent() {
    return sonComponentBuilderProvider.get();
  }

  public static final class Builder {
    private FatherModule fatherModule;

    private Builder() {}

    public FatherComponent build() {
      if (fatherModule == null) {
        this.fatherModule = new FatherModule();
      }
      return new DaggerFatherComponent(this);
    }

    public Builder fatherModule(FatherModule fatherModule) {
      this.fatherModule = Preconditions.checkNotNull(fatherModule);
      return this;
    }
  }

  private final class SonComponentBuilder implements SonComponent.Builder {
    private SonModule sonModule;

    @Override
    public SonComponent build() {
      if (sonModule == null) {
        this.sonModule = new SonModule();
      }
      return new SonComponentImpl(this);
    }
  }

  private final class SonComponentImpl implements SonComponent {
    private Provider<Airplane> provideAirplaneProvider;

    private MembersInjector<Son> sonMembersInjector;

    private SonComponentImpl(SonComponentBuilder builder) {
      assert builder != null;
      initialize(builder);
    }

    @SuppressWarnings("unchecked")
    private void initialize(final SonComponentBuilder builder) {

      this.provideAirplaneProvider = SonModule_ProvideAirplaneFactory.create(builder.sonModule);

      this.sonMembersInjector =
          Son_MembersInjector.create(
              DaggerFatherComponent.this.provideCarProvider, provideAirplaneProvider);
    }

    @Override
    public void inject(Son son) {
      sonMembersInjector.injectMembers(son);
    }
  }
}

```

#### FatherModule_ProvideCarFactory

```
public final class FatherModule_ProvideCarFactory implements Factory<Car> {
  private final FatherModule module;

  public FatherModule_ProvideCarFactory(FatherModule module) {
    assert module != null;
    this.module = module;
  }

  @Override
  public Car get() {
    return Preconditions.checkNotNull(
        module.provideCar(), "Cannot return null from a non-@Nullable @Provides method");
  }

  public static Factory<Car> create(FatherModule module) {
    return new FatherModule_ProvideCarFactory(module);
  }
}
```

#### Son_MembersInjector

```
public final class Son_MembersInjector implements MembersInjector<Son> {
  private final Provider<Car> carProvider;

  private final Provider<Airplane> airplaneProvider;

  public Son_MembersInjector(Provider<Car> carProvider, Provider<Airplane> airplaneProvider) {
    assert carProvider != null;
    this.carProvider = carProvider;
    assert airplaneProvider != null;
    this.airplaneProvider = airplaneProvider;
  }

  public static MembersInjector<Son> create(
      Provider<Car> carProvider, Provider<Airplane> airplaneProvider) {
    return new Son_MembersInjector(carProvider, airplaneProvider);
  }

  @Override
  public void injectMembers(Son instance) {
    if (instance == null) {
      throw new NullPointerException("Cannot inject members into a null reference");
    }
    instance.car = carProvider.get();
    instance.airplane = airplaneProvider.get();
  }

  public static void injectCar(Son instance, Provider<Car> carProvider) {
    instance.car = carProvider.get();
  }

  public static void injectAirplane(Son instance, Provider<Airplane> airplaneProvider) {
    instance.airplane = airplaneProvider.get();
  }
}
```

#### SonModule_ProvideAirplaneFactory

```
public final class SonModule_ProvideAirplaneFactory implements Factory<Airplane> {
  private final SonModule module;

  public SonModule_ProvideAirplaneFactory(SonModule module) {
    assert module != null;
    this.module = module;
  }

  @Override
  public Airplane get() {
    return Preconditions.checkNotNull(
        module.provideAirplane(), "Cannot return null from a non-@Nullable @Provides method");
  }

  public static Factory<Airplane> create(SonModule module) {
    return new SonModule_ProvideAirplaneFactory(module);
  }

  /** Proxies {@link SonModule#provideAirplane()}. */
  public static Airplane proxyProvideAirplane(SonModule instance) {
    return instance.provideAirplane();
  }
}
```


