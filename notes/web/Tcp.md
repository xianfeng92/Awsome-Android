# TCP协议

 TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，即在收发数据前，都需要与对面建立可靠的连接。


## TCP 报头 

先来看看它的报头：

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_header.png)


我们来分析分析每部分的含义和作用：

Source Port（源端口）：源端口号 （占用16位），发送端程序端口

Destination Port（目的端口）：目的端口号（占用16位），接收端程序端口

Sequence Number（发送数据序号）：用来标识从TCP发送端向TCP接收端发送的数据字节流，它表示在这个报文段中的第一个数据字节在数据流中的序号

Acknowledgment Number （ACK 确认号）： 32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。
不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。主要用来解决不丢包的问题。


TCP Flags（控制位）

TCP控制位（6位），每一位代表一个控制位，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：

* URG：此标志表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据

* ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中。有两个取值：0和1，为1的时候表示应答域有效，反之为0

* PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队

* RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包

* SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0。连接被响应的时候，SYN=1，ACK=1。
  这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；
  但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手。

* FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。


Window（窗口） ：窗口大小（16位），表示接收端可用缓冲区大小，根据缓冲区大小和每次包大小，就可以计算出同时处理的 TCP 包的个数。同时处理的包个数越多，则网速越快。

Checksum （校验和）： 用来检查 TCP 包是否完整（16位）

Urgent Pointer （紧急指针）：表示应紧急处理的数据位置（16位）。路由器可以把紧急的数据包优先处理。

Options（可选字段）：可选字段，可变长度，最长为40字节。（因为 Data Offset 最多能表示60个字节长度的 TCP 头信息，固定的 TCP 头部为 20 字节）

Padding （填充）：填充位。因为 Data Offset 只能表示 TCP 头部的长度 必须是 4 字节的整倍数。如果 Options 选项不足 4字节的整倍数，就需要 Padding 填充为 4 字节的整倍数。


## 连接管理机制

正常情况下, tcp需要经过三次握手建立连接, 四次挥手断开连接。

### 三次握手

三次握手：建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。

第一次: 
客户端 - - > 服务器 此时服务器知道了客户端要建立连接了 
第二次: 
客户端 < - - 服务器 此时客户端知道服务器收到连接请求了 
第三次: 
客户端 - - > 服务器 此时服务器知道客户端收到了自己的回应

到这里, 就可以认为客户端与服务器已经建立了连接。

刚开始, 客户端和服务器都处于 CLOSE 状态. 
此时, 客户端向服务器主动发出连接请求, 服务器被动接受连接请求.

1. TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 此时服务器就进入了 LISTEN（监听）状态 

2. TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 
   此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。

3. TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 
   此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据, 但是同样要消耗一个序号。

4.  TCP客户端进程收到确认后还要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1。

5. 此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

### 为什么不用两次?

__为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误__。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，
只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，
传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，
这将导致不必要的错误和资源的费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。


### 四次挥手

数据传输完毕后，双方都可以释放连接。

此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开连接，服务器被动断开连接。

1. 客户端进程发出连接释放报文，并且停止发送数据。
 
   释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送到服务器的数据的最后一个字节的序号加1），此时客户端进入FIN-WAIT-1（终止等待1）状态。 
   TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2. 服务器收到连接释放报文,发出确认报文，ACK=1，确认序号为 u+1，并且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（关闭等待）状态。
   TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。
   这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3. 客户端收到服务器的确认请求后，此时客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最终数据）
 
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，
   此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，确认序号为w+1，而自己的序列号是u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。
   注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
 
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。


### 为什么最后客户端还要等待 2*MSL的时间呢？

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，
应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的
所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。


### 如果已经建立了连接, 但是客户端突发故障了怎么办？

TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，
若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。


## 理解TIME_WAIT状态

  TCP协议规定,主动关闭连接的一方要处于TIME_ WAIT状态,等待2*MSL(maximum segment lifetime)的时间后才能回到CLOSED状态。


## 确认应答机制(ACK机制)
    
TCP将每个字节的数据都进行了编号, 即为序列号seq。

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_ack.png)

每一个ACK都带有对应的确认序列号ack, 意思是告诉发送者, 我已经收到了哪些数据；下一次你要从哪里开始发。比如， 客户端向服务器发送了1005字节的数据, 
服务器返回给客户端的确认序号是1003, 那么说明服务器只收到了1-1002的数据。1003, 1004, 1005都没收到，此时客户端就会从1003开始重发。


## 超时重传机制

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_timeout.png)

主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B。如果主机A在一个特定时间间隔内没有收到B发来的确认应答, 就会进行重发 
但是主机A没收到确认应答也可能是ACK丢失了。这种情况下, 主机B会收到很多重复数据。那么TCP协议需要识别出哪些包是重复的, 并且把重复的丢弃。
这时候利用前面提到的序列号, 就可以很容易做到去重。

### 超时时间如何确定？

最理想的情况下, 找到一个最小的时间, 保证 “确认应答一定能在这个时间内返回”。但是这个时间的长短, 随着网络环境的不同, 是有差异的。
如果超时时间设的太长, 会影响整体的重传效率；如果超时时间设的太短, 有可能会频繁发送重复的包。

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_timeout2.png)

TCP为了保证任何环境下都能保持较高性能的通信, 因此会动态计算这个最大超时时间。
Linux中(BSD Unix和Windows也是如此)，超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍。如果重发一次之后， 仍然得不到应答, 
等待 2*500ms 后再进行重传。 如果仍然得不到应答, 等待 4*500ms 进行重传。 依次类推, 以指数形式递增。 累计到一定的重传次数,TCP认为网络异常或者对端主机
出现异常, 强制关闭连接。


## 滑动窗口

前面说过TCP的确认应答机制, 对每一个发送的数据段，都要给一个ACK确认应答。收到ACK后再发送下一个数据段。这样做有一个比较大的缺点, 就是性能较差，
尤其是数据往返时间较长的时候。 


那么我们可不可以一次发送多个数据段呢? 


一个概念：窗口 

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_window.png)

窗口大小指的是无需等待确认应答就可以继续发送数据的最大值。上图的窗口大小就是4000个字节 (四个段)。发送前四个段的时候, 不需要等待任何ACK, 直接发送 
收到第一个ACK确认应答后, 窗口向后移动, 继续发送第五六七八段的数据...。因为这个窗口不断向后滑动, 所以叫做滑动窗口。操作系统内核为了维护这个滑动窗口, 
需要开辟发送缓冲区来记录当前还有哪些数据没有应答，只有ACK确认应答过的数据，才能从缓冲区删掉。


如果出现了丢包, 那么该如何进行重传呢?

此时分两种情况讨论:

1. 数据包已经收到, 但确认应答ACK丢了。

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_window2.png)


这种情况下, 部分ACK丢失并无大碍, 因为还可以通过后续的ACK来确认对方已经收到了哪些数据包。


2. 数据包丢失 

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_window3.png)

当某一段报文丢失之后, 发送端会一直收到 1001 这样的ACK, 就像是在提醒发送端 “我想要的是 1001” ，如果发送端主机连续三次收到了同样一个 “1001” 这样的应答, 
就会将对应的数据 1001 - 2000 重新发送。这个时候接收端收到了 1001 之后, 再次返回的ACK就是7001了。因为2001 - 7000接收端其实之前就已经收到了, 
被放到了接收端操作系统内核的接收缓冲区中。

这种机制被称为 “高速重发控制” ( 也叫 “快重传” )。


## 流量控制

接收端处理数据的速度是有限的。如果发送端发的太快， 导致接收端的缓冲区被填满, 这个时候如果发送端继续发送, 就会造成丢包, 进而引起丢包重传等一系列连锁反应。
因此TCP支持根据接收端的处理能力, 来决定发送端的发送速度。这个机制就叫做流量控制(Flow Control)。
接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段，通过ACK通知发送端; 窗口大小越大, 说明网络的吞吐量越高; 
接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端。发送端接受到这个窗口大小的通知之后, 就会减慢自己的发送速度。
如果接收端缓冲区满了, 就会将窗口置为0。这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段, 让接收端把窗口大小再告诉发送端。

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_flowControl.png)


那么接收端如何把窗口大小告诉发送端呢？

我们的TCP首部中, 有一个16位窗口大小字段, 就存放了窗口大小的信息。16位数字最大表示65536, 那么TCP窗口最大就是65536字节么? 
实际上, TCP首部40字节选项中还包含了一个窗口扩大因子M, 实际窗口大小是窗口字段的值左移 M 位(左移一位相当于乘以2)


## 拥塞控制

虽然TCP有了滑动窗口这个大杀器, 能够高效可靠地发送大量数据。但是如果在刚开始就发送大量的数据, 仍然可能引发一些问题。
因为网络上有很多计算机, 可能当前的网络状态已经比较拥堵。在不清楚当前网络状态的情况下, 贸然发送大量数据, 很有可能雪上加霜。

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_slowStart.png)

因此, TCP引入 慢启动 机制, 先发少量的数据, 探探路, 摸清当前的网络拥堵状态以后, 再决定按照多大的速度传输数据。


在此引入一个概念 拥塞窗口

* 发送开始的时候, 定义拥塞窗口大小为1

* 每次收到一个ACK应答, 拥塞窗口加1

* 每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口

像上面这样的拥塞窗口增长速度, 是指数级别的。“慢启动” 只是指初使时慢, 但是增长速度非常快。为了不增长得那么快, 此处引入一个名词叫做慢启动的阈值, 
当拥塞窗口的大小超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长。

少量的丢包, 我们仅仅是触发超时重传，大量的丢包, 我们就认为是网络拥塞。当TCP通信开始后, 网络吞吐量会逐渐上升，随着网络发生拥堵, 吞吐量会立刻下降

拥塞控制, 归根结底是TCP协议想尽可能快的把数据传输给对方, 但是又要避免给网络造成太大压力的折中方案。


## 延迟应答

如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小。假设接收端缓冲区为1M， 一次收到了500K的数据。如果立刻应答, 返回的窗口大小就是500K。
但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了。在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 也能处理过来。
如果接收端稍微等一会儿再应答, 比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M。

窗口越大, 网络吞吐量就越大, 传输效率就越高。TCP的目标是在保证网络不拥堵的情况下尽量提高传输效率。

那么所有的数据包都可以延迟应答么? 

肯定也不是，有两个限制：

1. 数量限制: 每隔N个包就应答一次

2. 时间限制: 超过最大延迟时间就应答一次

具体的数量N和最大延迟时间, 依操作系统不同也有差异。一般 N 取2, 最大延迟时间取200ms。



## 面向字节流

创建一个TCP的 socket, 同时在内核中创建一个 发送缓冲区 和一个 接收缓冲区。调用write时, 数据会先写入发送缓冲区中。如果发送的字节数太大, 
会被拆分成多个TCP的数据包发出。如果发送的字节数太小, 就会先在缓冲区里等待, 等到缓冲区大小差不多了, 或者到了其他合适的时机再发送出去。

![](https://github.com/xianfeng92/android-code-read/blob/master/images/tcp_seq.png)

接收数据的时候, 数据也是从网卡驱动程序到达内核的接收缓冲区。然后应用程序可以调用read从接收缓冲区拿数据。另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 
那么对于这一个连接, 既可以读数据, 也可以写数据, 这个概念叫做 全双工。

由于缓冲区的存在, 所以TCP程序的读和写不需要一一匹配，例如:

* 写100个字节的数据, 可以调用一次write写100个字节, 也可以调用100次write, 每次写一个字节。

* 读100个字节数据时, 也完全不需要考虑写的时候是怎么写的, 既可以一次read 100个字节, 也可以一次read一个字节, 重复100次。


## 粘包问题

首先要明确, 粘包问题中的 “包”, 是指应用层的数据包。在TCP的协议头中, 没有如同UDP一样的 “报文长度” 字段，但是有一个序号字段，
站在传输层的角度, TCP是一个一个报文传过来的，按照序号排好序放在缓冲区中. 
站在应用层的角度, 看到的只是一串连续的字节数据。那么应用程序看到了这一连串的字节数据, 就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包. 
此时数据之间就没有了边界, 就产生了粘包问题。

那么如何避免粘包问题呢? 

归根结底就是一句话, 明确两个包之间的边界


对于定长的包

* 保证每次都按固定大小读取即可 
例如上面的Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可

对于变长的包

* 可以在数据包的头部, 约定一个数据包总长度的字段, 从而就知道了包的结束位置 
还可以在包和包之间使用明确的分隔符来作为边界(应用层协议, 是程序员自己来定的, 只要保证分隔符不和正文冲突即可)

## TCP 异常情况

* 进程终止: 进程终止会释放文件描述符,仍然可以发送FIN。和正常关闭没有什么区别。

* 机器重启: 和进程终止的情况相同。

* 机器掉电/网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行 reset。
  即使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方是否还在。如果对方不在, 也会把连接释放。另外, 应用层的某些协议, 也有一些这样的检测机制。

## TCP 小结

为什么TCP这么复杂?

因为既要保证可靠性, 同时又要尽可能提高性能。

保证可靠性的机制：

* 校验和
* 序列号(按序到达)
* 确认应答
* 超时重传
* 连接管理
* 流量控制
* 拥塞控制

提高性能的机制:

* 滑动窗口
* 快速重传
* 延迟应答
* 捎带应答


定时器:

* 超时重传定时器
* 保活定时器
* TIME_WAIT定时器

基于 TCP 的应用层协议:

* HTTP 
* HTTPS 
* SSH 
* Telnet 
* FTP 
* SMTP 

## TCP 和 UDP 对比

1. TCP面向连接。UDP是无连接的，即发送数据之前不需要建立连接。

2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。UDP尽最大努力交付，即不保证可靠交付。

   Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

3. UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

4. 每一条TCP连接只能是点到点的。UDP支持一对一，一对多，多对一和多对多的交互通信

5. TCP对系统资源要求较多，UDP对系统资源要求较少。

### 为什么UDP有时比TCP更有优势？

UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。

1. 网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。

2. TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。

   采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，
   能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。



